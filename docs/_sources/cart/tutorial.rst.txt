.. _cart_tutorial:

=====================
SeaChat Cart Tutorial
=====================

This tutorial will walk through how to utilize SeaChat Cart for an e-commerce chatbot. 

.. contents:: Table of Contents
    :local:
    :depth: 3

For this tutorial we will imagine that we are building a new coffee shop bot from the ground up. Take it that the new bot can already handle basic intents, and can extract entities to slots. From there we will walk through adding menu and cart support.
For more detailed information about why and how the cart is implemented, see the :ref:`readme <cart_readme>` or the
:ref:`technical documentation <seachat_cart>`.

Creating the Menu
==================

Creating the menu can be approached a few different ways; if a virtual copy of the menu already exists, using a script to convert it to the SeaChat Cart format may be the quickest. It is also possible to scrape the menu from a website, or write it by hand. Create a new file in your bot folder: ``data/menu.json``.

.. TIP:: Menus can become quite large (Starbucks is over 100,000 lines), so it is highly encouraged to automate as much of this process as possible to avoid tedious menu construction by hand. 

Main Components
----------------
The ``menu`` consists of four top-level components: ``store_name``, ``currency``, ``products``, and ``modifiers``. The first two are quite simple to fill out: 

.. code-block:: JSON

    {
        "store_name": "Coffee Shop",
        "currency": "USD"
    }

``store_name`` and ``currency`` should both be strings, and the ``currency`` should be represented as the standard three-letter abbreviation for that currency. The ``products`` and ``modifiers`` fields of the menu are lists containing information about all the items available for purchase and how they can be modified. ``products`` are items that can be purchased on their own, while ``modifiers`` can only be added to a user's cart if they're attached to a product.

The Product list
-----------------
For our basic item example, we'll consider an ``Americano``. For this item, the customer must specify if they want room or not. Additionally, they can ask for sweetener packets. To add this product to the menu, we will add a new entry to the product list:

.. code-block:: JSON

    {
        "store_name": "Coffee Shop",
        "currency": "USD",
        "products": [
            {
                "name": "Americano"
            }
        ]
    }  

Basic Item Example
-------------------
**Basic Item attributes**

The item also needs the required information of ``id`` and ``type``. The ``id`` is a unique string which will be used to reference the correct item if there are multiple of the same name. The ``type`` gives information to the cart system about how the product should be manipulated and displayed. The type for a basic item is simply ``item``.

.. code-block:: JSON

    {
        "name": "Americano",
        "id": "000000",
        "type": "item"
    }  

Next, we can add ``price`` and ``calories`` information. ``price`` should be represented as a float, while ``calories`` can be represented as a single integer or a list of two integers, indicating a calorie range. Modifiers can include their own information about how many calories they add/remove from the item, so the base calories here should represent the calories of the product when it has no modifications.

.. code-block:: JSON

    {
        "name": "Americano",
        "id": "000000",
        "type": "item",
        "price": 2.35,
        "calories": 15
    }  

Additionally, we can add information to help the system categorize and query the item. This includes the fields: ``aliases``, ``categories``, and ``tags``. All three of these fields are represented as lists of strings. ``aliases`` are list synonyms for item names, and help assist with finding the correct item for the user if they don't use the exact name on the menu. ``tags`` carry semantic information and can help with extracting queries like "I want something sweet with coffee". Finally, ``categories`` represent which menu categories the item belongs to, and helps present items when the user is viewing the menu.

.. code-block:: JSON

    {
        "name": "Americano",
        "id": "000000",
        "type": "item",
        "price": 2.35,
        "calories": 15,
        "aliases": [
            "americano",
            "hot americano"
        ],
        "tags": [
            "hot",
            "espresso",
            "beverage"
        ],
        "categories": [
            "Hot Coffee",
            "Espresso"
        ]
    } 

Supplementary information such as ``description``, ``image``, ``ingredients``, and ``recommendation_score`` can be included. ``description`` and ``image`` are both strings, a description of the item and a url to an image. ``ingredients`` can be represented as a list of strings, and is useful if a user has some restrictions on what food/materials they will purchase. Lastly, the ``recommendation_score`` is an integer that is used to sort recommendations so that users are presented with the most popular or most promoted item.

.. code-block:: JSON

    {
        "name": "Americano",
        "id": "000000",
        "type": "item",
        "price": 2.35,
        "calories": 15,
        "aliases": [
            "americano",
            "hot americano"
        ],
        "tags": [
            "hot",
            "espresso",
            "beverage"
        ],
        "categories": [
            "Hot Coffee",
            "Espresso"
        ],
        "description": "Espresso shots with hot water",
        "ingredients": [
            "Espresso",
            "Water"
        ],
        "image": "https://coffee.americano.jpeg"
    } 


**Modifier Groups**

We've finished adding all of the basic attributes of the item; now we need to include information about how the item can be modified. For this item, the user must specify if they want room or not, and can optionally ask for a packet of sweetener. We will represent these different modifications as modifier groups. Each item contains a list called ``modifier_groups``, and each group within the list gives information about what options are available, how many at minimum/maximum may be selected, and whether or not the bot should ask the user about those specific options. First, we will add a ``modifier_group`` field to our item, and fill it with the name of our first group.

.. code-block:: JSON

    {
        "name": "Americano",
        "id": "000000",
        "type": "item",
        "price": 2.35,
        "calories": 15,
        "aliases": [
            "americano",
            "hot americano"
        ],
        "tags": [
            "hot",
            "espresso",
            "beverage"
        ],
        "categories": [
            "Hot Coffee",
            "Espresso"
        ],
        "description": "Espresso shots with hot water",
        "ingredients": [
            "Espresso",
            "Water"
        ],
        "image": "https://coffee.americano.jpeg",
        "modifier_groups": [
            {
                "name": "Room"
            }
        ]
    } 

We we also add a ``category`` field (to assist when users query about what type of options are available), ``minimum``/``maximum`` fields (integers that state the min and max number of modifiers that must be selected), and a ``query_users_for_modifiers`` field (that tells the bot whether or not it must ask the user about this group).

.. code-block:: JSON

    {
        "name": "Room",
        "category": "Fill Options",
        "minimum": 1,
        "maximum": 1,
        "query_users_for_modifiers": true,
        "modifiers": []
    }

**Modifiers**

Here is also included a ``modifiers`` list. This list contains the information about which modifiers are available, and how they influence the total price and calories of the item. For room, we will have two modifiers: ``room`` and ``no room``. Because this modifier just specifies how much water the customer wants, neither option changes to the total price or calories. We will construct a modifier object containing the ``name``, ``id`` (its unique id that references a standalone modifier specification in the menu's top-level modifiers list), whether the item comes as a ``default``, and the ``price_change`` & ``calorie_change``.

.. code-block:: JSON

    {
        "name": "Room",
        "category": "Fill Options",
        "minimum": 1,
        "maximum": 1,
        "query_users_for_modifiers": true,
        "modifiers": [
            {
                "name": "Room",
                "id": "000001",
                "default": true,
                "price_change": 0,
                "calorie_change": 0
            },
            {
                "name": "No Room",
                "id": "000002",
                "default": false,
                "price_change": 0,
                "calorie_change": 0
            },
        ]
    }

In this case, our users must select at least one option from this group. However, ``Room`` is applied as a default so if the group is already satisfied. But, because ``query_users_for_modifiers`` is set to true, the bot will still ask the user for their choice. 

We can use this first example to construct a modifier group for sweetener packets. For this group, no modifier is required, and the user can select as many of the options as they want.

.. code-block:: JSON

    {
        "name": "Sweetener Packets",
        "category": "Sweeteners",
        "minimum": 0,
        "maximum": -1,
        "query_users_for_modifiers": false,
        "modifiers": [
            {
                "name": "Sugar",
                "id": "000003",
                "default": false,
                "price_change": 0,
                "calorie_change": 5
            },
            {
                "name": "Splenda",
                "id": "000004",
                "default": false,
                "price_change": 0,
                "calorie_change": 0
            },            
            {
                "name": "Raw Sugar",
                "id": "000005",
                "default": false,
                "price_change": 0,
                "calorie_change": 10
            },
        ]
    }

In this example, we set the ``maximum`` to -1 to indicated that there is no limit to how many options can be selected from the group. Additionally, in this case ``query_users_for_modifiers`` is set to ``None``, and there are no default options, so sweetener packets will only be added to the item if the user specifically asks for it. As a final note, we can see that the ``calorie_change`` fields are being used. While the packets come complimentary, adding sugar to the item will cause the total calories to increase by 5-10.

**Variants**
There is one other field that can be included on modifiers: a variant list. Variants are slight variations of a modifier. ``Extra Cream`` might be a variant for a ``Cream`` modifier on the Americano. By definition only one ``variant`` of a modifier can be selected at once. So, if the user has already added cream, but then corrects themselves and specifies ``Extra Cream``, the ``Cream`` modifier will be removed, and the extra cream added. Here's an example of a modifier with variants:

.. code-block:: JSON

    {
        "name": "Cream",
        "id": "000006",
        "default": false,
        "price_change": 0,
        "calorie_change": 25,
        "variants": [
            {
                "name": "Extra Cream",
                "price_change": 0,
                "calorie_change": 35
            },
            {
                "name": "Light Cream",
                "price_change": 0,
                "calorie_change": 15
            }
        ]
    }

**Full Basic Item Json Example**

Now let's put all of this together to show our full menu with one complete item example:

.. code-block:: JSON

    {
        "store_name": "Coffee Shop",
        "currency": "USD",
        "products": [
            {
                "name": "Americano",
                "id": "000000",
                "type": "item",
                "price": 2.35,
                "calories": 15,
                "aliases": [
                    "americano",
                    "hot americano"
                ],
                "tags": [
                    "hot",
                    "espresso",
                    "beverage"
                ],
                "categories": [
                    "Hot Coffee",
                    "Espresso"
                ],
                "description": "Espresso shots with hot water",
                "ingredients": [
                    "Espresso",
                    "Water"
                ],
                "image": "https://coffee.americano.jpeg",
                "modifier_groups": [
                    {
                        "name": "Room",
                        "category": "Fill Options",
                        "minimum": 1,
                        "maximum": 1,
                        "query_users_for_modifier": true,
                        "modifiers": [
                            {
                                "name": "Room",
                                "id": "000001",
                                "default": true,
                                "price_change": 0,
                                "calorie_change": 0
                            },
                            {
                                "name": "No Room",
                                "id": "000002",
                                "default": false,
                                "price_change": 0,
                                "calorie_change": 0
                            },
                        ]
                    },
                    {
                        "name": "Sweetener Packets",
                        "category": "Sweeteners",
                        "minimum": 0,
                        "maximum": -1,
                        "query_users_for_modifier": false,
                        "modifiers": [
                            {
                                "name": "Sugar",
                                "id": "000003",
                                "default": false,
                                "price_change": 0,
                                "calorie_change": 5
                            },
                            {
                                "name": "Splenda",
                                "id": "000004",
                                "default": false,
                                "price_change": 0,
                                "calorie_change": 0
                            },            
                            {
                                "name": "Raw Sugar",
                                "id": "000005",
                                "default": false,
                                "price_change": 0,
                                "calorie_change": 10
                            },
                        ]
                    },
                    {
                        "name": "Creamer",
                        "category": "Add-ins",
                        "minimum": 0,
                        "maximum": -1,
                        "query_users_for_modifier": false,
                        "modifiers": [
                            {
                                "name": "Cream",
                                "id": "000006",
                                "default": false,
                                "price_change": 0,
                                "calorie_change": 25,
                                "variants": [
                                    {
                                        "name": "Extra Cream",
                                        "price_change": 0,
                                        "calorie_change": 35
                                    },
                                    {
                                        "name": "Light Cream",
                                        "price_change": 0,
                                        "calorie_change": 15
                                    }
                                ]
                            },
                            {
                                "name": "Non-dairy Creamer",
                                "id": "000007",
                                "default": false,
                                "price_change": 0,
                                "calorie_change": 10
                            }
                        ] 
                    }
                ]
            }
        ]
    }

So we have completed our first basic ``product`` entry in the menu. 

Combo Item Example
-------------------
Next we'll look at a slightly more complex type of product: the ``combo``. A combo item has the same basic structure as a basic item, but is of type ``combo``. The main difference between the two is that, while regular items can only be modified by modifiers, the combo's modifier groups can contain modifiers or *other products*. Take for example a coffee and pastry combo. Customers may have the choice between regular or decaf coffee, and their choice of muffin, croissant, or bagel. Let's construct an example.

.. code-block:: JSON

    [
        {
            "name": "Breakfast Pastry Combo",
            "id": "000008",
            "type": "combo",
            "price": 5.00,
            "calories": [280, 450],
            "aliases": [
                "coffee and pastry combo",
                "breakfast combo",
                "pastry combo"
            ],
            "tags": [
                "breakfast",
                "food",
                "beverage",
                "combo"
            ],
            "categories": [
                "Breakfast",
                "Combos"
            ],
            "description": "House coffee with your choice of pastry",
            "ingredients": [
                "Coffee",
                "Flour",
                "Butter",
                "Egg"
            ],
            "image": "https://coffee.pastry.combo.jpeg",
            "modifier_groups": [
                {
                    "name": "Coffee Choice",
                    "category": "Coffee Type",
                    "minimum": 1,
                    "maximum": 1,
                    "query_users_for_modifiers": false,
                    "modifiers": [
                        {
                            "name": "House Coffee",
                            "id": "000009",
                            "default": true,
                            "price_change": 0,
                            "calorie_change": 0
                        },
                        {
                            "name": "Decaf Coffee",
                            "id": "000010",
                            "default": false,
                            "price_change": 0,
                            "calorie_change": 0
                        },
                    ]
                },
                {
                    "name": "Pastry Choice",
                    "category": "Combo Choice",
                    "minimum": 1,
                    "maximum": 1,
                    "query_users_for_modifiers": true,
                    "modifiers": [
                        {
                            "name": "Muffin",
                            "id": "000011",
                            "default": false,
                            "price_change": 0,
                            "calorie_override": 290 
                        },
                        {
                            "name": "Croissant",
                            "id": "000012",
                            "default": false,
                            "price_change": 0,
                            "calorie_change": 280
                        },            
                        {
                            "name": "Bagel",
                            "id": "000013",
                            "default": false,
                            "price_change": 0,
                            "calorie_change": 440
                        },
                    ]
                }
            ]
        },
        {
            "name": "Bagel",
            "id": "000013",
            "...": "..."
        }
    ]

In this case, all of the objects in the modifier groups are referring to items on the ``product`` list. Additionally, because these are products, they can have their own modifier groups and can be customized by the user. It is essential that the ``id`` field points back to its stand-alone product on the product list. For example, if the user selects bagel, the cart can find item ``000013`` on the product list, and see that ``bagel`` has the option to be toasted.

The combo item can also have modifier groups containing modifier (rather than product) objects. A good example of this is if the combo item is 'here' or 'to-go'. The use of a ``modifier`` in this case is affecting the whole combo item.

Virtual Item Example
---------------------
The last type of product is of type ``virtual``. A virtual product is similar to a combo, but always contains an item in one of its modifier groups whose details and own modifier groups the bot should treat as if they were those of the main item. For example, rather than selecting a panini sandwich, then choosing between ham and turkey as modifiers, a user would select the virtual Panini item, then select either ``Ham Panini`` or ``Turkey Panini`` as a modifier. The bot should then treat this selection as it were the actual cart item when displaying information. The menu implementation is nearly identical to a combo, but the cart treats these two types slightly differently. Here's an example:

.. code-block:: JSON

    {
        "name": "Panini",
        "id": "0000014",
        "type": "virtual",
        "price": 7.50,
        "calories": 350,
        "aliases": [
            "panini sandwich",
            "pressed sandwich"
        ],
        "tags": [
            "lunch",
            "food",
            "savory"
        ],
        "categories": [
            "Lunch",
            "Sandwiches"
        ],
        "description": "A pressed Italian sandwich.",
        "image": "https://panini.jpeg",
        "modifier_groups": [
            {
                "name": "Panini Type",
                "category": "Panini Type",
                "minimum": 1,
                "maximum": 1,
                "query_users_for_modifiers": true,
                "modifiers": [
                    {
                        "name": "Turkey Bacon Panini",
                        "id": "000015",
                        "default": false,
                        "price_change": 0,
                        "calorie_change": 0
                    },
                    {
                        "name": "Ham Panini",
                        "id": "000010",
                        "default": false,
                        "price_change": 0,
                        "calorie_change": 0
                    },
                ]
            }
        ]
    }

Once the user has selected either ham or turkey panini, going forward the cart will always display ``Turkey Bacon Panini`` or ``Ham Panini`` as the item name, and the virtual item will inherit all of the customization available for either the turkey or ham item. 

The Modifier list
------------------
Now that we have completed examples for each of the types of products available in the ``products`` list, there is one more menu attribute to complete: the ``modifiers`` list. This list, similar to the ``products`` list, contains objects for each ``modifier`` available on the menu. We looked at how modifiers are instantiated when they are applied to an item, but each unique modifier also has a stand-alone representation in the ``modifiers`` list. This object is very similar to our basic product object, including many of the same top-level attributes. Here's an example using the 'sugar packet' example from before:

.. code-block:: JSON

    {
        "name": "Sugar",
        "id": "000003",
        "type": "modifier",
        "price": 0,
        "calories": 10,
        "description": "A packet of white sugar.",
        "image": "https://sugar.packet.jpg",
        "recommendation_score": 100,
        "aliases": [
            "white packet",
            "white sugar"
        ],
        "tags": [
            "sweetener",
            "packet"
        ]
    }

Here we have the sugar modifier object with all many of the fields we already saw in the ``product`` objects. Modifiers do have some unique attributes including ``countable``, ``quantity``, and ``unit_of_measure``, which help define how modifiers can be quantified. Additionally, the modifier also has a ``variants`` field, which should contain all the possible variants for that modifier, in the same format as they appeared when attached to an item. Here is a full example with the new fields:


.. code-block:: JSON

    {
        "name": "Sugar",
        "id": "000003",
        "type": "modifier",
        "price": 0,
        "calories": 10,
        "description": "A packet of white sugar.",
        "image": "https://sugar.packet.jpg",
        "recommendation_score": 100,
        "aliases": [
            "white packet",
            "white sugar"
        ],
        "tags": [
            "sweetener",
            "packet"
        ],
        "countable": true,
        "quantity": 1,
        "unit_of_measure": "packet(s)",
        "variants": {}
    }

.. IMPORTANT:: All modifiers that are found within a product's ``modifier_groups`` must have a matching ``id`` with the stand-alone modifier object in the ``modifiers`` list. The modifier attached to the item may reference the stand-alone modifier to get immutable information such as ``aliases``, ``description``, and ``image``.


A Complete Menu Example
------------------------
Now that we have completed an example of each element on the menu, we can put it all together to create a full example menu. View the full example :doc:`here<example_menu>`.


Generating Lookup Tables & Chatette Templates
==============================================
**Chatette**

The ``cart.py`` file has two methods to assist with exporting NLU training data from the menu. Additionally, there are two convenience scripts available to call these methods. The first script is ``generate_chatette.py``. We can run the script with the following command:

.. code-block::

    python generate_chatette.py {menu path} {output directory path}/menu.chatette

This outputs a `chatette <https://github.com/SimGus/Chatette>`_ formatted file that contains entity examples for ``items``, ``modifiers``, ``query_topics``. The item and modifier examples will include a set of the names of all of ``products``, ``modifiers``, and ``aliases`` present in the menu. The query topic examples include a set of all menu ``categories`` and ``tags``, helpful for when the user queries the menu. You can see an the full extracted file from our example menu :ref:`here<example_chatette>`.

To load this file into a common Chatette file, make sure all your chatette files are in the same directory and then include the following in your main chatette file::

    |menu.chatette // The file name of your Menu-specific templates

**Lookup Tables**

You can generate `Rasa lookup tables <https://rasa.com/docs/rasa/nlu-training-data/#lookup-tables>`_ with the following command:

.. code-block:: 

    python generate_lookup_tables.py {menu path} {output directory path}

This script will output a ``lookup_table.yml`` file. This file contains the same information as the chatette file, but just in a different format. You can see the result from our example menu :ref:`here<lookup_example>`. Lookup tables will be automatically included during the bot's training as long as they are in the ``data`` directory.

.. TIP:: While lookup table specifications and chatette generated examples can go in any NLU data file used by the bot, we suggest keeping three separate files: ``anno_nlu.md`` for annotate user utterances, ``chatette_nlu.md`` for generated examples, and ``extra_nlu.md``, which includes bot-specific NLU data not generated from templates or real users (such as lookup tables, dummy intents used for buttons, etc).

Writing the cart_config.yml File
=================================
Now that we have a working menu, we can prepare to integrate SeaChat Cart with our bot. First, we'll need to set up a cart config file so that we can adjust the cart settings and set up our menu path. Create a file called ``cart_config.yml`` in your bot directory. 

The following is a list of configurable parameters, with their default values listed:

+-----------------------+------------+--------------------------------------+-----------------------------+
| NAME                  | TYPE       | DESCRIPTION                          | DEFAULT VALUE               |
+=======================+============+======================================+=============================+
| MENU_PATHS            | List[Text] | A list of paths to menu files that   |  []                         |
|                       |            | will be loaded by the cart           |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+
| ES_HOST               | Text       | The host name for the ElasticSearch  | 'localhost'                 |
|                       |            | client (this value is set            |                             |
|                       |            | automatically if deployed to the     |                             |
|                       |            | cluster)                             |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+
| ES_PORT               | int        | The port name for the ElasticSearch  | 9200                        |
|                       |            | client (set automatically if deployed|                             |
|                       |            | to the cluster)                      |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+
| ES_TRY_LOCAL_FIRST    | bool       | Whether or not the cart should try   | True                        |
|                       |            | to connect to a local ElasticSearch  |                             | 
|                       |            | instance before trying whatever is   |                             |
|                       |            | specified in ES_HOST                 |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+
| FUZZY_MATCH_THRESH    | int        | A threshold for an string match      | 85                          |
|                       |            | (highly confident) when matching     |                             |
|                       |            | user requests to menu information.   |                             |
|                       |            | Between [0, 100]                     |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+
| FUZZY_SUGGEST_THRESH  | int        | A threshold for less-confident fuzzy | 70                          |
|                       |            | matching. If a fuzzy match score is  |                             |
|                       |            | below FUZZY_MATCH_THRESH but higher  |                             |
|                       |            | than FUZZY_SUGGEST_THRESH, the bot   |                             |
|                       |            | should confirm with the user or offer|                             |
|                       |            | suggestions                          |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+
| ES_MATCH_THRESH       | float      | A threshold for confident matching   | 3.5                         |
|                       |            | when using ElasticSearch             |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+
| ES_SUGGEST_THRESH     | float      | A threshold for returning item       | 1.8                         |
|                       |            | suggestions                          |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+
| ES_UNIQUE_THRESH      | float      | A threshold for determining unique   | .3                          |
|                       |            | matches with ElasticSearch. If ES is |                             |
|                       |            | asked to return one highly-confident |                             |
|                       |            | match, the second best match must be |                             |
|                       |            | lower in confidence by at least      |                             |
|                       |            | ES_UNIQUE_THRESH from the top match. |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+
| ES_MULTI_MATCH_TYPE   | Text       | Multi match type parameter for       | 'best_fields'               |
|                       |            | ElasticSearch. Can be either         |                             |
|                       |            | 'best_fields' or 'cross_fields'      |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+
| ES_MULTI_MATCH_FIELDS | List[Text] | Which fields to consult with multi   | ['modifier_names', 'tags',  |
|                       |            | match when querying for an item      | 'categories']               |
|                       |            | with ES.                             |                             |
+-----------------------+------------+--------------------------------------+-----------------------------+

You can find a full example of a ``cart_config.yml`` file :ref:`here <cart_config>`.

Integrating with Rasa
======================
Once a valid menu is created and the cart setting are configured, SeaChat Cart can be integrated with Rasa. The only point of contact between the bot and the cart system is through ``actions.py``. The bot is in charge of extracting intents & entities from user utterances and deciding which actions to execute next. During action execution, custom actions can call ``cart.py`` methods in order to pass slot data to the cart, manipulate the user's cart, request information from the cart, etc. 

Importing, Configuring, and Loading Menus
------------------------------------------
Before calling methods from ``cart.py``, however, there is a bit more configuration that must be done in the actions file itself. First, upon bot startup, the cart should be configured and the menus loaded. This can be accomplished with the follow code heading the actions file:

.. code-block:: Python

    from ngchat_cart import cart
    cart.load_config('./cart_config.yml')
    cart.load_menus()

This will initialize an instance of ``cart.py`` that has the appropriate menus and configurations for the bot. 

Session Start
--------------
Next, upon session start the bot will need to initialize a ``Cart`` object for the specific user. Here it is recommended to override Rasa's built in ``ActionSessionStart`` action. Add the action to your ``actions.py`` file, as is shown in the following example: 

.. code-block:: Python
    :linenos:

    class ActionSessionStart(Action):
        """Perform actions when user begins a session with the bot."""

        def name(self) -> Text:
            """Set action name to action_session_start."""
            return "action_session_start"

        async def run(
            self,
            dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]
        ) -> List[EventType]:
            """Initialize a user's cart and menu at session start.

            Return:
                SessionStarted action(required)
                Carry over slot sets
                Execute action_listen

            """
            user_cart = cart.get_user_cart(tracker.sender_id)
            # if the bot only uses one menu, simply load pre-load the menu
            user_cart.menu = user_cart.get_matching_menu(store_name='{name}')
            if not user_cart.menu:
                Warning("There was an error loading the menu")

            return [SessionStarted(),
                    SlotSet('cart_dump', user_cart.cart_dump()),
                    ActionExecuted('action_listen')]

.. IMPORTANT:: In order for this override to work, you will also need to add ``action_session_start`` to the actions list in your domain file.

This action is accomplishing several things. First, it is grabbing the user's existing cart, or creating a new cart object via the lru cache in the ``get_user_cart`` method. It is essential that cart objects are accessed via the user's ``sender_id``, otherwise users would all share one cart object, or the objects would get mixed up between users. Whenever accessing or manipulating the user cart, it must first be retrieved with the ``get_user_cart`` method. 

Second, if the bot only uses one menu, or there is a default menu, the bot should automatically load the menu at session start. If some information is needed prior to loading the menu, line 24 can be excluded.

Next, the action returns the ``SessionStarted`` event. This event *must* be returned first in the event list of this action. From there, you can also set any slots that the bot should have pre-filled at session start. In this case, the example uses the ``cart_dump`` method to fill the bot's ``cart_dump`` slot. The cart dump is essentially a dictionary representation of useful information extracted from the current cart status. This can be used by the dialogue manager to check the status of the cart and have the bot execute certain actions accordingly. This is optional for our simple tutorial bot, but becomes useful for more complex tasks.

Lastly, the bot must also return an ``ActionExecuted('action_listen')`` event. This will ensure that after the session start action has finished, the next action to be executed will always be ``action_listen``.

Calling Cart Methods from Actions
------------------------------------
Once the actions file is configured, all custom actions in the file can access the user cart and call methods from ``cart.py``. There are some actions that can be called on their own, and do not need to work together with other actions. These can be tasks like: showing the menu, giving suggestions, and checking the contents of the cart.

Other tasks, like adding an item to the cart, require a more complex navigation of dialogue & actions. For example, when a user requests an item to be added to the cart, the ``item`` and ``modifier`` slots should first be validated with the menu to make sure the user has requested a legitimate item. Next, a new ``CartItem`` object should be created and any user-specified modifiers added. The bot should then ask the user if they want to customize it any more, and if not finally confirm if the user wants to add it, then add the item to the cart. This flow will require several actions that work together, calling methods and passing slots back and forth. 

Action Examples
----------------

**Displaying the Menu**

In the dialogue tutorial, we set up a framework to execute two tasks: displaying the menu and adding an item to the cart. First, add ``action_display_menu`` to the actions list in your ``domain.yml`` file. Next, add the following action to your ``actions.py`` file.

.. code-block:: Python
    :linenos:

    class DisplayMenu(Action):

        def name(self) -> Text:
            return "action_display_menu"

        def run(self, dispatcher: CollectingDispatcher,
                tracker: Tracker, Domain: Dict[Text, Any]
                ) -> List[Dict[Text, Any]]:
            """Describe menu in general terms, such as categories."""
            # ALWAYS get the user cart with the sender id first
            user_cart = cart.get_user_cart(tracker.sender_id)

            if user_cart and user_cart.menu:
                # dispatch the menu description directly to the user
                dispatcher.utter_message(user_cart.menu.describe_menu())
            return []

In this case, the cart method is returning a string that can be directly presented to the user via the Rasa dispatcher. To have the bot execute this action, go back to the ``dialogue.yml`` file and replace ``utter_display_menu`` with ``action_display_menu``. This will result in the bot executing the custom action instead of just the utterance template when the user provides the ``display_menu`` intent.

.. code-block:: YAML

    $[display menu]:
    conditions:
        - INTENT.name == 'display_menu'
    actions:
        - action_display_menu
        - action_listen

**Validating an Item**

The bot should also be able to validate a user's requested item and add it to the cart. When the user gives the ``select_item`` intent, and the ``item`` slot is filled, the item should be validated by the cart. Add ``action_validate_item`` to you domain and the following action code to your actions file.

.. code-block:: Python
    :linenos:

    class ValidateItem(Action):

        def name(self) -> Text:
            return 'action_validate_item'

        def run(self, dispatcher: CollectingDispatcher,
                tracker: Tracker, domain: Dict[Text, Any]
                ) -> List[Dict[Text, Any]]:
            """Check that the requested item is in the menu."""
            # Get user cart
            user_cart = cart.get_user_cart(tracker.sender_id)

            # query the menu for a matching item
            item = tracker.get_slot('item')
            if item:
                match = user_cart.get_matching_menu_item(item, [])

                if not match:
                    return [SlotSet('item', None)]
                elif match:
                    user_cart.active_item = CartItem(match)
                    return [SlotSet('item', match.name)]
            else:
                return[SlotSet('item', None]

This action queries the menu for a matching item name. If it finds an exact match, it will set the ``item`` slot to the normalized item name from the menu. This will allow the dialogue policy to see the updated item and move forward with dialogue flow. It will also set the cart's ``active_item`` field with the validated item. This will allow other actions to directly access the object. If there is no matching item, the action will set the ``item`` slot to None. At this point, the action could also query the menu for similar items and offer the user some suggestions. Returning ``None``, in this case, tells the bot that the item was not successfully validated. 

Now we can go back to our dialogue state and replace ``utter_select_item`` with ``action_validate_item``. Now, ``action_validate_item`` will control which state is entered next, based how it sets the ``item`` slot.

**Adding an Item to the Cart**

Once an item is validated and converted to a ``CartItem``, it can be added to the user's cart.
Add ``action_add_item`` to you domain and the following action to your actions file.

.. code-block:: Python
    :linenos:

    class AddItem(Action):
        """Class to add item to cart."""

        def name(self) -> Text:
            """Set action name to action_add_to_cart."""
            return "action_add_item"

        def run(self, dispatcher: CollectingDispatcher,
                tracker: Tracker, domain: Dict[Text, Any]
                ) -> List[Dict[Text, Any]]:
            """Add item to cart."""
            # Get user cart
            user_cart = cart.get_user_cart(tracker.sender_id)

            # Add the active item to the cart
            user_cart.add_item(user_cart.active_item, tracker.sender_id)
            # affirm that the action is complete, and reset the active item
            dispatcher.utter_message(template='utter_added_item')
            user_cart.active_item = None

            # Reset all slots that may have been carrying information about the active item.
            return [SlotSet("item", None)]

Once the active item is fully customized (this could include adjusting size, quantity, or modifiers), the process of adding it to the cart is a matter of just calling one function. The most important part of this action is wiping the bot clean of any lingering information about the added item. Now that the item is in the cart, we don't want any of the information that we used when adding it to get mixed up with whatever the user asks next. If the user wants to access the added item, they will now need to request to modify or remove the item from the cart.

**Display the Cart**

The last thing we will implement is a method to display the current cart status to the user. Add ``action_display_cart`` to you domain and the following action to your actions file.

.. code-block:: Python
    :linenos:

    class DisplayCart(Action):

        def name(self) -> Text:
            return "action_display_cart"

        def run(self, dispatcher: CollectingDispatcher,
                tracker: Tracker, domain: Dict[Text, Any]
                ) -> List[Dict[Text, Any]]:
            """Display the contents of the user's cart."""
            # Get the user cart
            user_cart = cart.get_user_cart(tracker.sender_id)

            items = user_cart.get_item_names()
            total = user_cart.sum_price()

            dispatcher.utter_message(f"You have the following items in your cart: {items}.\nYour total is ${total}.")
            return[]

This action simply grabs the user cart, extracts the item names and total cost, and dispatches the information to the user. We will add this action to our dialogue state so that the cart information is displayed to the user after each item is added. Here is our full dialogue state for adding an item:

.. code-block:: YAML

    $[select item]:
    conditions:
        - INTENT.name == 'select_item'
    actions:
        - action_validate_item
    connections:
        - $[add item]:
            direct_connection: true
            conditions:
                - SLOTS.item is not None
            actions:
                - action_add_item
                - action_display_cart
                - action_listen
        - $[add item no item]:
            direct_connection: true
            conditions:
                - SLOTS.item is None
            actions:
                - utter_no_item_selected
                - action_display_menu
                - action_listen

See the full dialogue example :ref:`here <bot_dialogue>` and the full actions example :ref:`here <bot_actions>`.

Try It
=======

We can now test our bot with full cart support. Now that we are using actions, we must start the Rasa actions server and the ElasticSearch instance before running.

.. IMPORTANT:: Before running actions for the first time, the endpoint to the action server must be set up. Check the ``endpoints.yml`` file and un-comment the actions server url.

.. image:: ../../../image/finished_bot.PNG

Notes on Best Practices
========================
The following are some quick notes concerning best practices, to keep in mind while developing. 

**Pass by Reference**

Pass by Reference when possible to reduce string matching & ``ElasticSearch`` calls. While this isn't always possible (for example if you have to confirm something with the user or store a value as a string in a slot) it is worth keeping in mind as it can improve performance. Within actions, if calling multiple methods from ``cart.py``, do try to pass objects by reference whenever possible.

**Updating the Menu**

It is highly suggested when creating the menu to keep a master copy of the menu, and a secondary menu file containing only values that may change or be updated over time. This way, you always have a master copy of the menu they will never be changed or overwritten. The variable file will also be smaller and easier to update by hand. If you write a simple script to merge the two and produce and updated menu file, it can greatly simplify the process of updating the menu. 